<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swipe to Match</title>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        html { font-family: 'Inter', sans-serif; }
        @supports (font-variation-settings: normal) {
          html { font-family: 'Inter var', sans-serif; }
        }
        #item-card { transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; }
        .card-exit-left { transform: translateX(-150%) rotate(-15deg); opacity: 0; }
        .card-exit-right { transform: translateX(150%) rotate(15deg); opacity: 0; }
        .card-enter { transform: scale(0.8); opacity: 0; }
        .status-message { min-height: 2rem; transition: opacity 0.3s ease-in-out; }
        input[type="text"] {
             appearance: none; border: 1px solid #cbd5e1; padding: 0.5rem 0.75rem;
             border-radius: 0.375rem; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input[type="text"]:focus {
             outline: none; border-color: #4f46e5; box-shadow: 0 0 0 2px #c7d2fe;
        }
        .icon-button {
             width: 1em; height: 1em; vertical-align: -0.125em; display: inline-block;
        }
        #add-item-spinner { display: inline-block; }
        #add-item-spinner.hidden { display: none; }
        .danger-button { background-color: #f87171; color: white; }
        .danger-button:hover { background-color: #ef4444; }
        #welcome-message {
             font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; color: #4f46e5;
        }
        /* Styles for User Selection Modal */
        #user-selection-modal {
            position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center; z-index: 50;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
        }
        #user-selection-modal.visible {
            opacity: 1; visibility: visible; transition: opacity 0.3s ease-in-out, visibility 0s linear 0s;
        }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.75rem; text-align: center; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1); }
        .modal-button { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s ease-in-out; margin: 0 0.5rem; background-color: #a5b4fc; color: #3730a3; }
        .modal-button:hover { background-color: #818cf8; }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100 min-h-screen flex flex-col items-center justify-center p-4 text-slate-800">

    <div id="user-selection-modal">
        <div class="modal-content">
            <h2 class="text-xl font-semibold mb-6 text-slate-700">Who are you?</h2>
            <div class="flex justify-center">
                <button class="modal-button" onclick="selectAndStartUser('Amitha')">I am Amitha</button>
                <button class="modal-button" onclick="selectAndStartUser('Harsha')">I am Harsha</button>
            </div>
        </div>
    </div>

    <div class="w-full max-w-md bg-white rounded-xl shadow-xl p-6 text-center">

        <h2 id="welcome-message" class="text-center">Loading...</h2>

        <div class="mb-6 border-t pt-4">
            <button id="reset-swipes-btn" onclick="handleResetSwipes()" class="px-3 py-1 text-xs bg-orange-500 text-white rounded-md shadow-sm hover:bg-orange-600 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-button"><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 7.54 5.04"></path><path d="M3.51 15a9 9 0 0 0 12.95 3.96"></path></svg>
                Reset My Swipes
            </button>
        </div>

        <div class="mb-6 border-b pb-4">
            <h2 class="text-lg font-semibold mb-2 text-slate-600">Add New Item</h2>
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-2">
                <input type="text" id="new-item-title" placeholder="Enter item title" class="flex-grow w-full sm:w-auto border rounded-md px-3 py-1.5 focus:ring-indigo-500 focus:border-indigo-500" disabled>
                <button id="add-item-btn" type="button" onclick="handleAddItem()" class="w-full sm:w-auto px-4 py-1.5 bg-indigo-500 text-white rounded-md shadow-sm hover:bg-indigo-600 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center space-x-2" disabled>
                     <span>Add Item</span>
                    <span id="add-item-spinner" class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></span>
                 </button>
            </div>
             <p id="add-item-status" class="text-sm mt-2 text-slate-500 min-h-[1.25rem]"></p>
        </div>

        <div class="mb-6 text-right flex justify-between items-center">
            <button id="clear-all-btn" onclick="handleClearAllItems()" class="px-3 py-1.5 text-sm danger-button rounded-md shadow-sm transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-button"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                Clear All Items
            </button>
            <button id="refresh-btn" onclick="handleRefresh()" class="ml-2 px-3 py-1.5 text-sm bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-button refresh-icon"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>
                Refresh List
            </button>
        </div>

        <div id="item-card-container" class="relative h-48 flex items-center justify-center mb-6 overflow-hidden">
             <div id="loading-items" class="text-slate-500">Please identify yourself...</div>
        </div>

        <div id="swipe-buttons" class="flex justify-center space-x-6 opacity-0 transition-opacity duration-300">
             <button id="nope-btn" onclick="handleSwipe('left')" class="disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-16 h-16 bg-red-100 text-red-600 rounded-full shadow-md hover:bg-red-200 transition duration-200 disabled:hover:bg-red-100" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 14V2"/><path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"/></svg>
            </button>
            <button id="like-btn" onclick="handleSwipe('right')" class="disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-16 h-16 bg-green-100 text-green-600 rounded-full shadow-md hover:bg-green-200 transition duration-200 disabled:hover:bg-green-100" disabled>
                 <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>
            </button>
        </div>

         <div class="mt-4 status-message text-center">
            <p id="status-message" class="text-slate-600 font-medium"></p>
        </div>

        <div class="mt-6 border-t pt-4">
            <h3 class="text-md font-semibold mb-2 text-slate-600">Matches Found:</h3>
            <ul id="match-list" class="list-disc list-inside text-left text-sm text-slate-500 pl-2">
                <li id="no-matches" class="">No matches yet.</li>
            </ul>
        </div>

    </div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = "https://ide-9yxi.onrender.com";
        // Removed LOCAL_STORAGE_KEY_PREFIX
        const LOCAL_STORAGE_USER_KEY = 'swipeAppCurrentUser'; // Keep this for user selection persistence
        const ITEM_POLLING_INTERVAL_MS = 10000;
        const MATCH_POLLING_INTERVAL_MS = 7000;
        const VALID_USERS = ["Amitha", "Harsha"];

        // --- State Variables ---
        let currentUser = null;
        let items = [];
        let currentItemIndex = 0;
        let userSwipedData = {}; // Now holds data fetched from backend
        let matchedItems = [];
        let isLoading = false;
        let isAddingItem = false;
        let isClearingItems = false;
        let itemPollIntervalId = null;
        let matchPollIntervalId = null;
        let currentBackendItemCount = 0;
        let knownMatchCount = 0;

        // --- DOM Elements ---
        // ... (references remain the same) ...
        const welcomeMessageEl = document.getElementById('welcome-message');
        const itemCardContainer = document.getElementById('item-card-container');
        const loadingItemsIndicator = document.getElementById('loading-items');
        const nopeBtn = document.getElementById('nope-btn');
        const likeBtn = document.getElementById('like-btn');
        const swipeButtons = document.getElementById('swipe-buttons');
        const statusMessageEl = document.getElementById('status-message');
        const matchListEl = document.getElementById('match-list');
        const noMatchesLi = document.getElementById('no-matches');
        const newItemTitleInput = document.getElementById('new-item-title');
        const addItemBtn = document.getElementById('add-item-btn');
        const addItemStatusEl = document.getElementById('add-item-status');
        const addItemSpinner = document.getElementById('add-item-spinner');
        const refreshBtn = document.getElementById('refresh-btn');
        const resetSwipesBtn = document.getElementById('reset-swipes-btn');
        const clearAllBtn = document.getElementById('clear-all-btn');
        const userSelectionModal = document.getElementById('user-selection-modal');


        // --- Helper Functions ---
        // Removed localStorage helpers for swipes: getSwipedData, saveSwipedData, updateLocalStorageSwipe
        // isItemSwiped now checks the in-memory userSwipedData fetched from backend
        function isItemSwiped(itemId) {
             return userSwipedData.hasOwnProperty(itemId);
        }
        // findNextUnswipedItemIndex remains the same, uses the updated isItemSwiped
        function findNextUnswipedItemIndex(startIndex) {if (!currentUser) return -1;let nextIndex = startIndex;while (nextIndex < items.length) {const item = items[nextIndex];if (!isItemSwiped(item.id)) { return nextIndex; }nextIndex++;}return nextIndex;}

        // --- Polling Functions ---
        // (Polling functions remain the same)
        function startPolling() {stopPolling();if (!currentUser) return;console.log("Polling Start (Items & Matches)...");itemPollIntervalId = setInterval(checkItemsForChanges, ITEM_POLLING_INTERVAL_MS);pollForNewMatches(); matchPollIntervalId = setInterval(pollForNewMatches, MATCH_POLLING_INTERVAL_MS);}
        function stopPolling() {if (itemPollIntervalId) { clearInterval(itemPollIntervalId); itemPollIntervalId = null; } if (matchPollIntervalId) { clearInterval(matchPollIntervalId); matchPollIntervalId = null; } console.log("Polling Stop.");}
        async function checkItemsForChanges() {
            if (isLoading || isAddingItem || isClearingItems || !currentUser) {console.log("Item Polling skipped."); return;}
            console.log("Item Polling Check...");
            try {
                const response = await fetch(`${API_BASE_URL}/items`); if (!response.ok) {console.warn(`Item Polling fail: ${response.status}`); return;}
                const data = await response.json(); const fetchedItems = data.items || []; const backendCount = fetchedItems.length;
                console.log(`Item Polling: Backend=${backendCount}, Known=${currentBackendItemCount}`);
                if (backendCount > currentBackendItemCount) {
                    console.log("Item Polling: New items detected! Updating list.");
                    const wasPreviouslyEmpty = currentItemIndex >= items.length;
                    items = fetchedItems; currentBackendItemCount = backendCount;
                    setStatus("New items added to stack.", false); clearStatus(2500);
                    if (wasPreviouslyEmpty && items.length > 0) { console.log("Item Polling: Stack was empty, displaying first."); currentItemIndex = findNextUnswipedItemIndex(0); displayCurrentItem(); }
                }
            } catch (error) {console.error("Item Polling error:", error);}
        }
        async function pollForNewMatches() {
            if (isLoading || isAddingItem || isClearingItems || !currentUser) { console.log("Match Polling skipped."); return; }
            console.log("Match Polling Check...");
            try {
                const response = await fetch(`${API_BASE_URL}/matches`); if (!response.ok) { console.warn(`Match Polling fail: ${response.status}`); return; }
                const data = await response.json(); const currentMatches = data.matched_items || []; const currentMatchCount = currentMatches.length;
                console.log(`Match Polling: Current matches=${currentMatchCount}, Known matches=${knownMatchCount}`);
                if (currentMatchCount > knownMatchCount) {
                    console.log("Match Polling: New match(es) detected!");
                    matchedItems = currentMatches; knownMatchCount = currentMatchCount; updateMatchDisplay();
                    if (!statusMessageEl.textContent.includes("Match found on")) { setStatus("🎉 New match found!", false); /* Don't auto-clear */ }
                } else if (currentMatchCount < knownMatchCount) {
                     console.log("Match Polling: Matches seem to have decreased.");
                     matchedItems = currentMatches; knownMatchCount = currentMatchCount; updateMatchDisplay();
                }
            } catch (error) { console.error("Match Polling error:", error); }
        }

        // --- Modal Functions ---
        function showUserSelectionModal() { userSelectionModal.classList.add('visible'); }
        function hideUserSelectionModal() { userSelectionModal.classList.remove('visible'); }

        // --- Core Functions ---

        // NEW function to fetch user swipes from backend
        async function fetchUserSwipes(userId) {
            if (!userId) {
                userSwipedData = {};
                return;
            }
            console.log(`Fetching swipe history for ${userId}...`);
            setStatus(`Loading ${userId}'s swipe history...`);
            try {
                const response = await fetch(`${API_BASE_URL}/swipes/${userId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                userSwipedData = data.swiped_items || {}; // Store fetched data
                console.log(`Swipe history loaded for ${userId}:`, userSwipedData);
                clearStatus(500);
            } catch (error) {
                console.error(`Error fetching swipes for ${userId}:`, error);
                setStatus(`Error loading swipe history: ${error.message}`, true);
                userSwipedData = {}; // Reset on error
                clearStatus(3000);
            }
        }


        async function loadUserDataAndStartApp(user) {
             currentUser = user;
             welcomeMessageEl.textContent = `Welcome, ${currentUser}!`;

             // Fetch swipe data from backend instead of localStorage
             await fetchUserSwipes(currentUser);

             console.log(`Loaded swipe data for ${currentUser}:`, userSwipedData); // Log fetched data
             enableAllActionButtons();
             newItemTitleInput.disabled = false;
             currentItemIndex = 0;
             await fetchMatches(); // Fetch initial matches first
             await fetchItems(); // Then fetch items
             currentItemIndex = findNextUnswipedItemIndex(0); // Find first unswiped based on fetched data
             currentBackendItemCount = items.length;
             displayCurrentItem();
             startPolling();
        }

        function selectAndStartUser(user) {
            if (VALID_USERS.includes(user)) {
                try { localStorage.setItem(LOCAL_STORAGE_USER_KEY, user); } catch(e) { console.error("Failed to save user selection", e); }
                hideUserSelectionModal();
                loadUserDataAndStartApp(user);
            }
        }

        async function initializeApp() {
            let storedUser = null;
            try { storedUser = localStorage.getItem(LOCAL_STORAGE_USER_KEY); } catch(e) { console.error("Failed to read user from LS", e); }
            if (storedUser && VALID_USERS.includes(storedUser)) {
                console.log(`Found user ${storedUser} in localStorage.`);
                loadUserDataAndStartApp(storedUser);
            } else {
                console.log("No valid user found in localStorage. Showing selection modal.");
                showUserSelectionModal();
                disableAllActionButtons();
                newItemTitleInput.disabled = true;
            }
        }

        async function fetchItems() {
            // (Fetch logic remains largely the same, just doesn't interact with swipe localStorage)
            if (isLoading && !isAddingItem && !isClearingItems) return; isLoading = true; stopPolling();
            refreshBtn.disabled = true; resetSwipesBtn.disabled = true; clearAllBtn.disabled = true; addItemBtn.disabled = true;
            loadingItemsIndicator.textContent = "Fetching items..."; loadingItemsIndicator.style.display = 'block'; itemCardContainer.innerHTML = ''; itemCardContainer.appendChild(loadingItemsIndicator); disableSwipeButtons(); clearStatus();
            try {
                const response = await fetch(`${API_BASE_URL}/items`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json(); items = data.items || []; console.log("Items fetched:", items);
            } catch (error) { console.error("Error fetching items:", error); loadingItemsIndicator.textContent = "Error loading items."; loadingItemsIndicator.style.display = 'block'; setStatus(`Error fetching items: ${error.message}`, true); items = []; }
            finally { isLoading = false; if (currentUser) { enableAllActionButtons(); } startPolling(); }
        }

        function displayCurrentItem() {
            // (Display logic remains the same, uses isItemSwiped which now checks in-memory fetched data)
            itemCardContainer.innerHTML = ''; if (!currentUser) { itemCardContainer.innerHTML = `<div class="text-slate-500 font-medium p-4">Please identify yourself first.</div>`; disableSwipeButtons(); return; }
            if (currentItemIndex < 0 || currentItemIndex >= items.length) { let message = "No items loaded in backend."; if (items.length > 0) { message = "No more items to swipe! Add or reset?"; } itemCardContainer.innerHTML = `<div class="text-slate-500 font-medium p-4">${message}</div>`; disableSwipeButtons(); return; }
            const item = items[currentItemIndex]; const card = document.createElement('div'); card.id = 'item-card'; card.className = 'absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-blue-100 to-purple-200 p-6 rounded-lg shadow-md text-slate-700 card-enter';
            card.innerHTML = `<h3 class="text-xl font-bold mb-2">${item.title || 'Unnamed Item'}</h3>`; itemCardContainer.appendChild(card);
            void card.offsetWidth; requestAnimationFrame(() => card.classList.remove('card-enter')); enableDisableSwipeButtons();
        }


        async function handleSwipe(direction) {
            if (!currentUser || currentItemIndex >= items.length || isLoading || isAddingItem || isClearingItems) { return; }
            const item = items[currentItemIndex]; const itemId = item.id;

            // --- Remove local storage update ---
            // updateLocalStorageSwipe(currentUser, itemId, direction);
            // --- Add swipe to in-memory data immediately for UI responsiveness ---
            userSwipedData[itemId] = direction;
            console.log(`In-memory swipe recorded: ${currentUser}, ${itemId}, ${direction}`);


            const card = document.getElementById('item-card'); if (card) { card.classList.add(direction === 'left' ? 'card-exit-left' : 'card-exit-right'); }
            disableSwipeButtons(); setStatus("Sending swipe..."); isLoading = true; stopPolling(); refreshBtn.disabled = true; resetSwipesBtn.disabled = true; clearAllBtn.disabled = true;
            try {
                // Backend call already handles storing the swipe server-side
                const response = await fetch(`${API_BASE_URL}/swipe`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user_id: currentUser, item_id: itemId, direction: direction }) });
                if (!response.ok) {
                    console.error(`Backend swipe failed: ${response.statusText}`);
                    // Optional: Revert in-memory swipe if backend fails?
                    delete userSwipedData[itemId];
                } else {
                    const result = await response.json(); console.log("Backend swipe result:", result);
                    if (result.match_status?.includes("Match found")) { setStatus(`🎉 Match found on "${item.title}"!`); await fetchMatches(); }
                    else { clearStatus(1500); }
                }
            } catch (error) {
                 console.error("Error sending swipe to backend:", error);
                 setStatus(`Backend swipe error: ${error.message}`, true); clearStatus(3000);
                 // Optional: Revert in-memory swipe on error
                 delete userSwipedData[itemId];
            } finally {
                isLoading = false; enableAllActionButtons(); startPolling();
                // Find next unswiped item based on the updated in-memory userSwipedData
                const nextIndex = findNextUnswipedItemIndex(currentItemIndex + 1);
                setTimeout(() => { currentItemIndex = nextIndex; displayCurrentItem(); }, 300);
            }
        }

        async function handleAddItem() {
            // (No changes needed here as it doesn't interact with swipe storage)
            if (!currentUser) { setAddItemStatus("Cannot add item: User not identified.", true); clearAddItemStatus(3000); return; }
            const title = newItemTitleInput.value.trim(); if (!title) { setAddItemStatus("Please enter an item title.", true); clearAddItemStatus(3000); return; }
            if (isAddingItem || isLoading || isClearingItems) return;
            isAddingItem = true; stopPolling(); disableAllActionButtons(); addItemSpinner.classList.remove('hidden'); setAddItemStatus("Adding item...");
            const fetchOptions = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ title: title }) };
            try {
                console.log(`Executing fetch to ${API_BASE_URL}/add_item with method: ${fetchOptions.method}`); const response = await fetch(`${API_BASE_URL}/add_item`, fetchOptions); const result = await response.json();
                if (!response.ok) throw new Error(result.error || `HTTP error! status: ${response.status}`);
                console.log("Add item result:", result); setAddItemStatus(`"${result.item?.title || title}" added! Refreshing list...`, false); newItemTitleInput.value = '';
                await fetchItems(); currentItemIndex = findNextUnswipedItemIndex(0); currentBackendItemCount = items.length; displayCurrentItem(); clearAddItemStatus(2000);
            } catch (error) { console.error("Error adding item:", error); setAddItemStatus(`Error: ${error.message}`, true); clearAddItemStatus(4000); }
            finally { isAddingItem = false; enableAllActionButtons(); addItemSpinner.classList.add('hidden'); startPolling(); }
        }

        function handleRefresh() {
            // (No changes needed here)
             if (!currentUser || isLoading || isAddingItem || isClearingItems) return; console.log("Refreshing item list..."); setStatus("Refreshing list...");
             fetchItems().then(() => { currentItemIndex = findNextUnswipedItemIndex(0); currentBackendItemCount = items.length; displayCurrentItem(); clearStatus(1000); }); fetchMatches();
        }

        // --- Updated handleResetSwipes ---
        async function handleResetSwipes() {
            if (!currentUser || isLoading || isAddingItem || isClearingItems) { return; }
            if (confirm(`Are you sure you want to reset swipe history for ${currentUser} on the server?`)) {
                console.log(`Resetting swipes for ${currentUser} on backend...`);
                setStatus("Resetting swipes...");
                isLoading = true; // Use general loading flag
                stopPolling();
                disableAllActionButtons();

                try {
                    // Call the new backend endpoint
                    const response = await fetch(`${API_BASE_URL}/swipes/${currentUser}`, {
                        method: 'DELETE',
                    });
                    const result = await response.json(); // Try to parse JSON

                    if (!response.ok) {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }

                    console.log("Backend reset result:", result);
                    userSwipedData = {}; // Clear in-memory data on success

                    // Clear matches list locally
                    matchedItems = [];
                    knownMatchCount = 0;
                    updateMatchDisplay();

                    setStatus("Swipe history reset successfully.", false);
                    clearStatus(2000);

                    // Reset view to the first item
                    currentItemIndex = findNextUnswipedItemIndex(0);
                    displayCurrentItem();

                } catch (error) {
                     console.error("Error resetting swipes on backend:", error);
                     setStatus(`Error resetting swipes: ${error.message}`, true);
                     clearStatus(4000);
                     // Should we refetch swipes here to be safe? Maybe not necessary.
                } finally {
                    isLoading = false;
                    enableAllActionButtons();
                    startPolling();
                }
            }
        }
        // --- End Updated handleResetSwipes ---

        async function handleClearAllItems() {
            // (No changes needed here)
            if (!currentUser || isLoading || isAddingItem || isClearingItems) { return; }
            if (confirm("DANGER! Are you sure you want to clear ALL items from the backend? This affects everyone!")) {
                console.log("Attempting to clear all items..."); isClearingItems = true; stopPolling(); disableAllActionButtons(); setStatus("Clearing all items...");
                try {
                    const response = await fetch(`${API_BASE_URL}/items`, { method: 'DELETE' }); const result = await response.json();
                    if (!response.ok) { throw new Error(result.error || `HTTP error! status: ${response.status}`); }
                    console.log("Clear all items result:", result); setStatus(result.message || "All items cleared successfully.", false);
                    items = []; currentItemIndex = 0; currentBackendItemCount = 0; matchedItems = []; knownMatchCount = 0; updateMatchDisplay(); displayCurrentItem(); clearStatus(3000);
                } catch (error) { console.error("Error clearing all items:", error); setStatus(`Error: ${error.message}`, true); clearStatus(4000); }
                finally { isClearingItems = false; enableAllActionButtons(); startPolling(); }
            }
        }

        function disableAllActionButtons() { addItemBtn.disabled = true; refreshBtn.disabled = true; resetSwipesBtn.disabled = true; clearAllBtn.disabled = true; newItemTitleInput.disabled = true; disableSwipeButtons(); }
        function enableAllActionButtons() { const userIsValid = !!currentUser; addItemBtn.disabled = !userIsValid; refreshBtn.disabled = !userIsValid; resetSwipesBtn.disabled = !userIsValid; clearAllBtn.disabled = !userIsValid; newItemTitleInput.disabled = !userIsValid; if(userIsValid) { enableDisableSwipeButtons(); } else { disableSwipeButtons(); } }
        async function fetchMatches() {
            // (No changes needed here, but updates knownMatchCount)
            if (!currentUser) return; try { const response = await fetch(`${API_BASE_URL}/matches`); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const data = await response.json(); matchedItems = data.matched_items || []; knownMatchCount = matchedItems.length; console.log("Matches fetched:", matchedItems); updateMatchDisplay(); } catch (error) { console.error("Error fetching matches:", error); if (!statusMessageEl.textContent.includes("Match found")) { setStatus(`Error fetching matches: ${error.message}`, true); clearStatus(3000); } }
        }
        function updateMatchDisplay() {matchListEl.innerHTML = '';if (matchedItems.length === 0) {matchListEl.appendChild(noMatchesLi);noMatchesLi.style.display = 'list-item';} else {noMatchesLi.style.display = 'none';matchedItems.forEach(item => {const li = document.createElement('li');li.textContent = item.title || `Item ID: ${item.id}`;matchListEl.appendChild(li);});}}
        function enableDisableSwipeButtons() {const itemAvailable = currentItemIndex < items.length;const enabled = currentUser && itemAvailable && !isLoading && !isAddingItem && !isClearingItems;nopeBtn.disabled = !enabled;likeBtn.disabled = !enabled;swipeButtons.style.opacity = enabled ? '1' : '0.5';}
        function disableSwipeButtons() {nopeBtn.disabled = true;likeBtn.disabled = true;swipeButtons.style.opacity = '0.5';}
        function setStatus(message, isError = false) {statusMessageEl.textContent = message;statusMessageEl.style.color = isError ? '#dc2626' : '#475569';statusMessageEl.style.opacity = '1';}
        function clearStatus(delay = 0) {if (!statusMessageEl.textContent.includes("Match found")) {setTimeout(() => { statusMessageEl.style.opacity = '0'; }, delay);}}
        function setAddItemStatus(message, isError = false) {addItemStatusEl.textContent = message;addItemStatusEl.style.color = isError ? '#dc2626' : '#16a34a';}
        function clearAddItemStatus(delay = 0) {setTimeout(() => { addItemStatusEl.textContent = ''; }, delay);}

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            newItemTitleInput.addEventListener('keypress', function (e) { if (e.key === 'Enter') { handleAddItem(); } });
        });

    </script>
</body>
</html>
